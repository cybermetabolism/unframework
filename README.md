### Contents

1. [Proof of Concept](/proof-of-concept.md)
2. [What is Unframework](/README.md)

# What is Unframework
## Part I. - Solving dichotomy between the real and digital world 

The recommended way to create successful applications (including Dapps) is to program them for simple use cases. Simple use case is well understandable for a user: It cointains his need (initial state), steps leading to the final state (transition path) and an expected result (final state).

But we get drawbacks when we isolate a use case and all its components inside one app. It creates a dichotomy between the real and digital world. Our need (initial state) is unknown in the digital world until we realize that need and open up the right application.  

![Use case isolated inside an app](/docs/images/isolated-use-case.png?raw=true "Use case isolated inside an app")

Nor can we get new solutions as long as we do not know they exist. Last but not least, a transition path and final state are irreversibly determined once we open up an app. This greatly limits our possibilities.

The very high level goal of Unframework is to enable a user to get the solution without even knowing the need or solution exists. It enables to fragment use cases into atomic states and unbound these states from apps.

![Atomic states](/docs/images/atomic-states.png?raw=true "Atomic states")

As a result, states will become combinable and interpretable through any client. An initial state will no longer necessarily determine a transition path or a final state. There will be many transition paths and solutions “competing” for same states and altering each other.